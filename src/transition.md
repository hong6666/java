## 并发事务带来哪些问题

- **脏读（读取未提交数据）**：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据干净、纯粹，此时B事务更改了它，这个数据不再纯粹，这个时候A事务又读取了这个变脏的数据，但是事务B良性发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。
- **不可重复读（前后多次读取，数据内容不一致）**：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，称为不可重复读。
- **幻读（前后多次读取，数据总量不一致）**：事务A在执行读取操作，需要统计两次数据的总量，前一次查询数据总量后，此时事务B执行了新增（删除）数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，称为幻读。

**不可重复读和脏读的区别?**

脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。幻读和不可重复读都是读取了另一事务已经提交的数据

**不可重复读和幻读的区别？**

(1)不可重复读是读取了其他事务更改的数据，**针对update操作**

解决：不可重复读查询的都是**同一个数据项**，使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

解决：幻读针对的是**一批数据整体**，使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。
